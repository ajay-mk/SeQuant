<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File README.md &mdash; SeQuant  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=fd3f3429" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<link href="../_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            SeQuant
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../source/readme.html">SeQuant: symbolic tensor algebra in C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/readme.html#synopsis">Synopsis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/readme.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/readme.html#getting-started">Getting started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../source/readme.html#build-harness">Build harness</a></li>
<li class="toctree-l2"><a class="reference internal" href="../source/readme.html#using">Using</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../source/readme.html#id1">Getting Started</a></li>
<li class="toctree-l3"><a class="reference internal" href="../source/readme.html#register-index-spaces">Register Index Spaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="../source/readme.html#quasiparticles">Quasiparticles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../source/readme.html#operators">Operators</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../source/readme.html#developers">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/readme.html#acknowledgement">Acknowledgement</a></li>
<li class="toctree-l1"><a class="reference internal" href="../source/install.html">SeQuant: installation guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../source/install.html#tl-dr">TL;DR</a></li>
<li class="toctree-l2"><a class="reference internal" href="../source/install.html#prerequisites">Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="../source/install.html#configure">Configure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../source/install.html#useful-cmake-variables">Useful CMake variables</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../source/install.html#build">Build</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SeQuant</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Program Listing for File README.md</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/ajay-mk/SeQuant/blob/master/doc/sphinx/api/program_listing_file_README.md.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="program-listing-for-file-readme-md">
<span id="program-listing-file-readme-md"></span><h1>Program Listing for File README.md<a class="headerlink" href="#program-listing-for-file-readme-md" title="Link to this heading"></a></h1>
<p>↰ <a class="reference internal" href="file_README.md.html#file-readme-md"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">README.md</span></code>)</p>
<div class="highlight-markdown notranslate"><div class="highlight"><pre><span></span><span class="gh">SeQuant: symbolic tensor algebra in C++</span>
<span class="gh">=======================================</span>

<span class="gh"># Synopsis</span>

SeQuant is a framework for performing symbolic algebra of tensors over scalar fields (regular tensors) and over
operator fields (tensor operators in, e.g., quantum many-body physics).
In addition to symbolic manipulation it can numerically evaluate
(with an appropriate external tensor backend) general
tensor algebra expressions.

Computer algebra systems (CAS) like SeQuant are typically implemented within generic CAS like Mathematica or Maple, or
using high-level languages like Python. In fact, version 1 of SeQuant was written in Mathematica. However, the
performance of high-level languages not sufficient for practical use cases.
SeQuant is written in C++ and is designed to be as efficient as possible without loss of generality.

<span class="gh"># Installation</span>

The short version:

<span class="k">-</span><span class="w"> </span>configure (from top SeQuant source dfirectory): <span class="sb">`cmake -B build -S . -DCMAKE_INSTALL_PREFIX=/path/where/sequant/to/be/installed`</span>
<span class="k">-</span><span class="w"> </span>build and test: <span class="sb">`cmake --build build --target install`</span>

The long version is in file [<span class="nt">INSTALL.md</span>](<span class="na">INSTALL.md</span>).

<span class="gh"># Getting started</span>

<span class="gu">## Build harness</span>
We will only consider how to use SeQuant from within an existing codebase that has a [<span class="nt">CMake</span>](<span class="na">https://cmake.org</span>) harness. If SeQuant has already been built and installed, it should be sufficient to add the SeQuant install prefix to <span class="sb">`CMAKE_INSTALL_PREFIX`</span> CMake cache variable and adding the following lines to the <span class="sb">`CMakeLists.txt`</span> file in your codebase:

<span class="sb">```cmake</span>
<span class="nb">find_package</span><span class="p">(</span><span class="s">SeQuant</span><span class="w"> </span><span class="s">CONFIG</span><span class="w"> </span><span class="s">REQUIRED</span><span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">your_executable_or_library_target</span><span class="w"> </span><span class="s">PUBLIC</span><span class="w"> </span><span class="s">SeQuant::SeQuant</span><span class="p">)</span>
<span class="sb">```</span>

It is often desirable to build SeQuant from source within a standalone codebase; this case be done using the [<span class="nt">FetchContent CMake module</span>](<span class="na">https://cmake.org/cmake/help/latest/module/FetchContent.html</span>) as follows:

<span class="sb">```cmake</span>
<span class="nb">find_package</span><span class="p">(</span><span class="s">SeQuant</span><span class="w"> </span><span class="s">CONFIG</span><span class="p">)</span>
<span class="nb">if</span><span class="w"> </span><span class="p">(</span><span class="s">NOT</span><span class="w"> </span><span class="s">TARGET</span><span class="w"> </span><span class="s">SeQuant::SeQuant</span><span class="p">)</span>
<span class="w">    </span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span><span class="w"> </span><span class="s">3.14.0</span><span class="p">)</span><span class="w">  </span><span class="c"># for FetchContent_MakeAvailable</span>
<span class="w">    </span><span class="nb">include</span><span class="p">(</span><span class="s">FetchContent</span><span class="p">)</span>
<span class="w">    </span><span class="nb">FetchContent_Declare</span><span class="p">(</span><span class="s">sequant</span>
<span class="w">            </span><span class="s">GIT_REPOSITORY</span><span class="w">      </span><span class="s">https://github.com/ValeevGroup/SeQuant2.git</span>
<span class="w">            </span><span class="p">)</span>
<span class="w">    </span><span class="nb">FetchContent_MakeAvailable</span><span class="p">(</span><span class="s">sequant</span><span class="p">)</span>
<span class="w">    </span><span class="nb">add_library</span><span class="p">(</span><span class="s">SeQuant::SeQuant</span><span class="w"> </span><span class="s">ALIAS</span><span class="w"> </span><span class="s">SeQuant</span><span class="p">)</span>
<span class="nb">endif</span><span class="p">()</span>
<span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">your_executable_or_library_target</span><span class="w"> </span><span class="s">PUBLIC</span><span class="w"> </span><span class="s">SeQuant::SeQuant</span><span class="p">)</span>
<span class="sb">```</span>

<span class="gu">## Using</span>

SeQuant is a general-purpose symbolic tensor algebra, but the primary use case is in quantum many-body physics. The following is a brief tutorial on using SeQuant for this purpose.

<span class="gu">### Getting Started</span>

To get started let&#39;s use SeQuant to apply [<span class="nt">Wick&#39;s theorem</span>](<span class="na">https://en.wikipedia.org/wiki/Wick&#39;s_theorem</span>) to a simple product of elementary (creation and annihilation) fermionic operators:

$$
a<span class="ge">_{p_</span>3} a<span class="ge">_{p_</span>4} a^\dagger_{p_1} a^\dagger_{p_2}.
$$

This is achieved by the following SeQuant program:

```c++
<span class="gh">#include &lt;SeQuant/core/wick.hpp&gt;</span>

int main() {
  using namespace sequant;

  Index p1(L&quot;p_1&quot;), p2(L&quot;p_2&quot;), p3(L&quot;p_3&quot;), p4(L&quot;p_4&quot;);

  auto cp1 = fcrex(p1), cp2 = fcrex(p2);
  auto ap3 = fannx(p3), ap4 = fannx(p4);

  std::wcout &lt;&lt; to_latex(ap3 * ap4 * cp1 * cp2) &lt;&lt; &quot; = &quot;
             &lt;&lt; to_latex(FWickTheorem{ap3 * ap4 * cp1 * cp2}
                             .full_contractions(false)
                             .compute())
             &lt;&lt; std::endl;

  return 0;
}
<span class="sb">```</span>

<span class="sb">N.B. All _core_ user-facing SeQuant code lives in C++ namespace `sequant`, from now on we will assume this namespace has been imported via `using namespace sequant` and will omit the explicit namespace qualification for SeQuant components.</span>

<span class="sb">Running this program should produce a LaTeX expression for this formula:</span>

<span class="sb">$$</span>
<span class="sb">{{a_ {{p_3}}}{a_ {{p_4}}}{a^{{p_1}}}{a^{{p_2}}}} = { \bigl( - {{a^{{p_1}{p_2}}_ {{p_3}{p_4}}}} - {{s^{{p_1}}_ {{p_3}}}{s^{{p_2}}_ {{p_4}}}} + {{s^{{p_1}}_ {{p_3}}}{a^{{p_2}}_ {{p_4}}}} - {{s^{{p_1}}_ {{p_4}}}{a^{{p_2}}_ {{p_3}}}} + {{s^{{p_2}}_ {{p_3}}}{s^{{p_1}}_ {{p_4}}}} - {{s^{{p_2}}_ {{p_3}}}{a^{{p_1}}_ {{p_4}}}} + {{s^{{p_2}}_ {{p_4}}}{a^{{p_1}}_ {{p_3}}}}\bigr) },</span>
<span class="sb">$$</span>

<span class="sb">where the tensor notation is used to denote elementary and composite _normal-ordered_ (or, shortly, _normal_) operators:</span>

<span class="sb">$$a^p \equiv a_p^\dagger,$$</span>

<span class="sb">$$</span>
<span class="sb">a^{p_1 p_2 \dots p_c}_ {q_1 q_2 \dots q_a} \equiv a_ {p_1}^\dagger  a_ {p_2}^\dagger \dots a_ {p_c}^\dagger a_ {q_a} \dots a_ {q_2} a_ {q_1},</span>
<span class="sb">$$</span>


<span class="sb">$s^p_q \equiv \langle q | p \rangle$ denotes inner products (&quot;overlaps&quot;) of 1-particle states. Wick&#39;s theorem can of course be applied directly to products of normal composite operators, e.g,</span>

<span class="sb">```c++</span>
<span class="sb">  auto nop1 = ex&lt;FNOperator&gt;(std::array{p1, p2}, std::array{p3, p4});</span>
<span class="sb">  auto nop2 = ex&lt;FNOperator&gt;(std::array{p5}, std::array{p6, p7});</span>

<span class="sb">  std::wcout &lt;&lt; to_latex(nop1 * nop2) &lt;&lt; &quot; = &quot;</span>
<span class="sb">             &lt;&lt; to_latex(FWickTheorem{nop1 * nop2}</span>
<span class="sb">                             .full_contractions(false)</span>
<span class="sb">                             .compute())</span>
<span class="sb">             &lt;&lt; std::endl;</span>
<span class="sb">```</span>

produces

$$
{{a^{{p_1}{p_2}}_ {{p_3}{p_4}}}{a^{␣\,{p_5}}_ {{p_6}{p_7}}}} = { \bigl({a^{␣\,{p_1}{p_2}{p_5}}_ {{p_3}{p_4}{p_6}{p_7}}} - {{s^{{p_5}}_ {{p_4}}}{a^{␣\,{p_1}{p_2}}_ {{p_3}{p_6}{p_7}}}} + {{s^{{p_5}}_ {{p_3}}}{a^{␣\,{p_1}{p_2}}_ {{p_4}{p_6}{p_7}}}}\bigr) },
$$

where $␣$ is used in number-nonconserving operators to point out the empty &quot;slots&quot;.

Same algebra can be performed for bosons:

$$
{{b^{{p_1}{p_2}}_ {{p_3}{p_4}}}{b^{{p_5}{p_6}}_ {␣\,{p_7}}}} = \bigl( {b^{{p_5}{p_1}{p_2}{p_6}}_ {␣\,{p_3}{p_4}{p_7}}} + {{s^{{p_6}}_ {{p_3}}}{b^{{p_5}{p_2}{p_1}}_ {␣\,{p_4}{p_7}}}} + {{s^{{p_5}}_ {{p_3}}}{b^{{p_1}{p_2}{p_6}}_ {␣\,{p_4}{p_7}}}}
$$

$$
\qquad \qquad \qquad \qquad \quad + ~ {{s^{{p_6}}_ {{p_4}}}{b^{{p_5}{p_1}{p_2}}_ {␣\,{p_3}{p_7}}}} + {{s^{{p_5}}_ {{p_4}}}{b^{{p_2}{p_1}{p_6}}_ {␣\,{p_3}{p_7}}}} + {{s^{{p_5}}_ {{p_3}}}{s^{{p_6}}_ {{p_4}}}{b^{{p_1}{p_2}}_ {␣\,{p_7}}}} + {{s^{{p_6}}_ {{p_3}}}{s^{{p_5}}_ {{p_4}}}{b^{{p_2}{p_1}}_ {␣\,{p_7}}}} \bigr)
$$

where $b$ denotes normal bosonic operators constructed analogously with the normal fermionic operators $a$, is obtained via

```c++
  auto nop3 = ex&lt;BNOperator&gt;(std::array{p1, p2}, std::array{p3, p4});
  auto nop4 = ex&lt;BNOperator&gt;(std::array{p5, p6}, std::array{p7});

  std::wcout &lt;&lt; to_latex(nop3 * nop4) &lt;&lt; &quot; = &quot;
             &lt;&lt; to_latex(BWickTheorem{nop3 * nop4}
                             .full_contractions(false)
                             .compute())
             &lt;&lt; std::endl;
<span class="sb">```</span>

<span class="sb">Tensor and operator constructors can take arbitrary (uniform) sequences of objects that can be converted to `Index`; all of the following are equivalent:</span>

<span class="sb">```c++</span>
<span class="sb">auto nop1 = ex&lt;FNOperator&gt;(std::array{p1, p2}, std::array{p3, p4});</span>
<span class="sb">auto nop1 = ex&lt;FNOperator&gt;(std::vector{p1, p2}, std::array{L&quot;p3&quot;, L&quot;p4&quot;});</span>
<span class="sb">auto nop1 = ex&lt;FNOperator&gt;(std::set{&quot;p1&quot;, &quot;p2&quot;}, std::vector{L&quot;p3&quot;, L&quot;p4&quot;});</span>
<span class="sb">```</span>

Note the mixed use of narrow- (<span class="sb">`&quot;&quot;`</span>) and wide-character (<span class="sb">`L&quot;&quot;`</span>) strings. SeQuant uses wide characters internally to make it easy parsing of strings into characters without additional dependencies. Thus the use of wide characters is recommended (but not required) as it is more efficient.

<span class="gu">### Register Index Spaces</span>

Tensor expressions annotated by [<span class="nt">abstract indices</span>](<span class="na">https://en.wikipedia.org/wiki/Abstract_index_notation</span>) are common. In some contexts all tensor modes refer to the same range or underlying vector space (as in all examples shown so far); then there is no need to distinguish modes of different types. But in some contexts indices carry important semantic meaning. For example, the energy expression in the [<span class="nt">coupled-cluster method</span>](<span class="na">https://doi.org/10.1017/CBO9780511596834</span>),

$$
E<span class="ge">_\mathrm{CC} =  F^{a_</span>1}_ {i_1} t^{i_1}_ {a_1} + \frac{1}{4} \bar{g}^{a_1 a<span class="ge">_2}_</span> {i_1 i<span class="ge">_2} (t^{i_</span>1 i<span class="ge">_2}_</span> {a_1 a<span class="ge">_2} + 2 t^{i_</span>1}_ {a_1} t^{i_2}_ {a_2})
$$

contains tensors with 2 types of modes, denoted by $i$ and $a$, that represent single-particle (SP) states occupied and unoccupied in the reference state, respectively. To simplify symbolic manipulation of such expressions SeQuant allows to define a custom vocabulary of index spaces and to define their set-theoretic relationships. The following example illustrates the full space denoted by $p$ partitioned into occupied $i$ and unoccupied $a$ base subspaces:

```c++
<span class="gh">#include &lt;SeQuant/core/context.hpp&gt;</span>
<span class="gh">#include &lt;SeQuant/core/index.hpp&gt;</span>

int main() {
  using namespace sequant;
  IndexSpaceRegistry isr;

  // base spaces
  isr.add(L&quot;i&quot;, 0b01)
     .add(L&quot;a&quot;, 0b10);
  // union of 2 base spaces
  // can create manually, as isr.add(L&quot;p&quot;, 0b11) , or explicitly ...
  isr.add_union(L&quot;p&quot;, {L&quot;i&quot;, L&quot;a&quot;}); // union of i and a

  // can access unions and intersections of base and composite spaces
  assert(isr.unIon(L&quot;i&quot;, L&quot;a&quot;) == isr.retrieve(L&quot;p&quot;));
  assert(isr.intersection(L&quot;p&quot;, L&quot;i&quot;) == isr.retrieve(L&quot;i&quot;));

  // to use the vocabulary defined by isr use it to make a Context object and make it the default
  set_default_context(Context(std::move(isr)));

  // now can use space labels to construct Index objects representing said spaces
  Index i1(L&quot;i_1&quot;);
  Index a1(L&quot;a_1&quot;);
  Index p1(L&quot;p_1&quot;);

  // set theoretic operations on spaces
  assert(i1.space().intersection(a1.space()) == IndexSpace::null);
}
<span class="sb">```</span>

<span class="sb">This and other vocabularies commonly used in quantum many-body context are supported out-of-the-box by SeQuant; their definition is in `SeQuant/domain/mbpt/convention.hpp`. The previous example is equivalent to the following:</span>

<span class="sb">```c++</span>
<span class="sb">#include &lt;SeQuant/core/context.hpp&gt;</span>
<span class="sb">#include &lt;SeQuant/domain/mbpt/convention.hpp&gt;</span>

<span class="sb">int main() {</span>
<span class="sb">  using namespace sequant;</span>
<span class="sb">  using namespace sequant::mbpt;</span>

<span class="sb">  // makes 2 base spaces, i and a, and their union</span>
<span class="sb">  auto isr = make_min_sr_spaces();</span>
<span class="sb">  set_default_context(Context(isr));</span>

<span class="sb">  // set theoretic operations on spaces</span>
<span class="sb">  auto i1 = Index(L&quot;i_1&quot;);</span>
<span class="sb">  auto a1 = Index(L&quot;a_1&quot;);</span>
<span class="sb">  assert(i1.space().attr().intersection(a1.space().attr()).type() ==</span>
<span class="sb">         IndexSpace::Type::null);</span>
<span class="sb">  assert(i1.space().attr().intersection(a1.space().attr()).qns() ==</span>
<span class="sb">         Spin::any);</span>
<span class="sb">}</span>
<span class="sb">```</span>

Bitset representation of index spaces allows to define set-theoretic operations naturally. Bitset-based representation is used not only for index space <span class="ge">_type_</span> attribute (<span class="sb">`IndexSpace::Type`</span>) but also for the <span class="ge">_quantum numbers_</span> attribute (<span class="sb">`IndexSpace::QuantumNumbers`</span>). The latter can be used to represent spin quantum numbers, particle types, etc.
The main difference of the last example with the original example is that the <span class="sb">`make_min_sr_spaces()`</span> factory changes the quantum numbers used by default (<span class="sb">`mbpt::Spin::any`</span>) to make spin algebraic manipulations (like tracing out spin degrees of freedom) easier. Users can create their own definitions to suit their needs, but the vast majority of users will not need to venture outside of the predefined vacbularies.

Notice that the set-theoretic operations are only partially automated. It is the user&#39;s responsibility to define any and all unions and intersections of base spaces that they may encounter in their context. For this reason <span class="sb">`IndexSpaceRegistry`</span> has its own <span class="sb">`unIon()`</span> and <span class="sb">`intersection()`</span> methods that perform error checking to ensure that only registered spaces are defined.

<span class="gu">### Quasiparticles</span>

In most cases we are interested in using SeQuant to manipulate expressions involving operators in normal order relative to a vacuum state with a finite number of particles, rather than with respect to the genuine vacuum with zero particles. The choice of vacuum state as well as other related traits (whether the SP states are orthonormal, etc.) is defined by the implicit global context. The SeQuant programs until now used the genuine vacuum. The active context can be examined by calling <span class="sb">`get_default_context()`</span>, changed via <span class="sb">`set_default_context()`</span>, and reset to the default via <span class="sb">`reset_default_context()`</span>:

```c++
<span class="gh">#include &lt;SeQuant/core/context.hpp&gt;</span>

int main() {
  using namespace sequant;

  // the default is to use genuine vacuum
  assert(get_default_context().vacuum() == Vacuum::Physical);
  // now set the context to a single product of SP states
  set_default_context(Context{Vacuum::SingleProduct, IndexSpaceMetric::Unit, BraKetSymmetry::symm});
  assert(get_default_context().vacuum() == Vacuum::SingleProduct);
  // reset the context back to the default
  reset_default_context();
  assert(get_default_context().vacuum() == Vacuum::Physical);

  return 0;
}
<span class="sb">```</span>

<span class="sb">However, to deal with the single-product vacuum it is necessary to register at least one space and announce it as occupied in the vacuum state:</span>

<span class="sb">```c++</span>
<span class="sb">isr.add(L&quot;y&quot;, 0b01).vacuum_occupied_space(L&quot;i&quot;);</span>
<span class="sb">```</span>

or, shorter,

```c++
isr.add(L&quot;y&quot;, 0b01, is_vacuum_occupied);
<span class="sb">```</span>

<span class="sb">It is also necessary to specify the _complete_ space (union of all base spaces) so that the the space of unoccupied SP states can be determined:</span>

<span class="sb">```c++</span>
<span class="sb">isr.add(L&quot;y&quot;, 0b01, is_vacuum_occupied)</span>
<span class="sb">   .add(L&quot;z&quot;, 0b10)</span>
<span class="sb">   .add(L&quot;p&quot;, 0b11, is_complete);</span>
<span class="sb">```</span>


The Wick&#39;s theorem code itself is independent of the choice of vacuum:

```c++
<span class="gh">#include &lt;SeQuant/core/context.hpp&gt;</span>
<span class="gh">#include &lt;SeQuant/core/wick.hpp&gt;</span>

int main() {
  using namespace sequant;

  set_default_context(Context{IndexSpaceRegistry{}
                                  .add(L&quot;y&quot;, 0b01, is_vacuum_occupied)
                                  .add(L&quot;z&quot;, 0b10)
                                  .add(L&quot;p&quot;, 0b11, is_complete),
                              Vacuum::SingleProduct});

  auto cp1 = fcrex(L&quot;p_1&quot;), cp2 = fcrex(L&quot;p_2&quot;);
  auto ap3 = fannx(L&quot;p_3&quot;), ap4 = fannx(L&quot;p_4&quot;);

  std::wcout &lt;&lt; to_latex(ap3 * cp1 * ap4 * cp2) &lt;&lt; &quot; = &quot;
             &lt;&lt; to_latex(FWickTheorem{ap3 * cp1 * ap4 * cp2}
                             .full_contractions(false)
                             .compute())
             &lt;&lt; std::endl;

  return 0;
}
<span class="sb">```</span>

<span class="sb">produces</span>

<span class="sb">$$</span>
<span class="sb">{{\tilde{a}_ {{p_3}}}{\tilde{a}^{{p_1}}}{\tilde{a}_ {{p_4}}}{\tilde{a}^{{p_2}}}} = \bigl({\tilde{a}^{{p_1}{p_2}}_ {{p_3}{p_4}}} - {{s^{{p_1}}_ {{z_1}}}{s^{{z_1}}_ {{p_3}}}{\tilde{a}^{{p_2}}_ {{p_4}}}} - {{s^{{p_2}}_ {{z_1}}}{s^{{z_1}}_ {{p_4}}}{\tilde{a}^{{p_1}}_ {{p_3}}}} - {{s^{{p_1}}_ {{y_1}}}{s^{{y_1}}_ {{p_4}}}{\tilde{a}^{{p_2}}_ {{p_3}}}}</span>
<span class="sb">$$</span>

<span class="sb">$$</span>
<span class="sb">\qquad \qquad \qquad \quad + ~ {{s^{{p_2}}_ {{z_1}}}{s^{{z_1}}_ {{p_3}}}{\tilde{a}^{{p_1}}_ {{p_4}}}} + {{s^{{p_1}}_ {{z_1}}}{s^{{p_2}}_ {{z_2}}}{s^{{z_1}}_ {{p_3}}}{s^{{z_2}}_ {{p_4}}}} + {{s^{{p_1}}_ {{y_1}}}{s^{{p_2}}_ {{z_1}}}{s^{{z_1}}_ {{p_3}}}{s^{{y_1}}_ {{p_4}}}}\bigr) .</span>
<span class="sb">$$</span>

<span class="sb">Note that:</span>

<span class="sb">- the tilde in $\tilde{a}$ denotes normal order with respect to single-product vacuum, and</span>
<span class="sb">- Einstein summation convention is implied, i.e., indices that appear twice in a given product (once in superscript, once in a subscript) are summed over.</span>

<span class="sb">## Operators</span>

<span class="sb">Development of SeQuant is primarily motivated by the perturbative many-body methods, collectively referred to here as Many-Body Perturbation Theory (MBPT). Examples of such methods include the [coupled-cluster (CC) method](https://doi.org/10.1017/CBO9780511596834) and [GW](https://doi.org/10.1103/PhysRev.139.A796). The typical use case is to compute canonical forms of products of operators. For example, consider the coupled-cluster doubles (CCD) method.</span>
<span class="sb">_Amplitudes_ $t^{i_1 i_2}_ {a_1 a_2}$ of the cluster operator,</span>

<span class="sb">$$</span>
<span class="sb">\hat{t} \equiv \hat{t}_ 2 = \frac{1}{4} t^{i_1 i_2}_ {a_1 a_2} a_ {i_1 i_2}^{a_1 a_2},</span>
<span class="sb">$$</span>

<span class="sb">are determined by solving the CCD equations:</span>

<span class="sb">$$</span>
<span class="sb">\forall i_1, i_2, a_1, a_2: \quad 0 = \langle0\vert a^{i_1 i_2}_ {a_1 a_2} \exp(-\hat{t}_ 2) \hat{H} \exp(\hat{t}_ 2) \vert 0 \rangle = \langle0\vert a^{i_1 i_2}_ {a_1 a_2} \bigl( \hat{H} + [\hat{H}, \hat{t}_ 2] + \frac{1}{2} [[\hat{H}, \hat{t}_ 2], \hat{t}_ 2] \bigr) \vert 0 \rangle.</span>
<span class="sb">$$</span>

<span class="sb">A pedestrian way to compose such expression is to define a cluster operator object using SeQuant tensors and normal-ordered operators:</span>

<span class="sb">```c++</span>
<span class="sb">auto t2 =</span>
<span class="sb">      ex&lt;Constant&gt;(rational(1, 4)) *</span>
<span class="sb">      ex&lt;Tensor&gt;(L&quot;t&quot;, std::array{L&quot;a_1&quot;, L&quot;a_2&quot;}, std::array{L&quot;i_1&quot;, L&quot;i_2&quot;},</span>
<span class="sb">                 Symmetry::antisymm) *</span>
<span class="sb">      ex&lt;FNOperator&gt;(std::array{L&quot;a_1&quot;, L&quot;a_2&quot;}, std::array{L&quot;i_1&quot;, L&quot;i_2&quot;});</span>
<span class="sb">```</span>

The normal-ordered Hamiltonian is defined similarly as a sum of 1- and 2-body contributions:

```c++
auto H = ex&lt;Tensor&gt;(L&quot;f&quot;, std::array{L&quot;p_1&quot;}, std::array{L&quot;p_2&quot;},
                    Symmetry::nonsymm) *
         ex&lt;FNOperator&gt;(std::array{L&quot;p_1&quot;}, std::array{L&quot;p_2&quot;})
         +
         ex&lt;Constant&gt;(rational(1, 4)) *
         ex&lt;Tensor&gt;(L&quot;g&quot;, std::array{L&quot;p_1&quot;, L&quot;p_2&quot;},
                          std::array{L&quot;p_3&quot;, L&quot;p_4&quot;}, Symmetry::antisymm) *
         ex&lt;FNOperator&gt;(std::array{L&quot;p_1&quot;, L&quot;p_2&quot;},
                        std::array{L&quot;p_3&quot;, L&quot;p_4&quot;});
<span class="sb">```</span>

<span class="sb">Note that the compact definition of the Hamiltonian is due to the use of the union ($p$) of base occupied ($i$) and unoccupied ($a$) spaces. Many other symbolic algebras only support use of nonoverlapping base spaces, in terms of which Hamiltonian and other tensor expressions would have a much more verbose form.</span>

<span class="sb">Commutator of the Hamiltonian and cluster operator is trivially composed:</span>

<span class="sb">```c++</span>
<span class="sb">inline auto commutator(auto op1, auto op2) {</span>
<span class="sb">  return simplify(op1 * op2 - op2 * op1);</span>
<span class="sb">}</span>

<span class="sb">auto c_ht = commutator(H, t2);</span>
<span class="sb">```</span>

Note the use of <span class="sb">`simplify`</span> to rewrite an expression in a simpler form. Its role will be emphasized later.

Unfortunately, we immediately run into the limitation of the &quot;pedestrian&quot; approach. Namely,
the double commutator cannot be correctly obtained as

```c++
auto c_htt = ex&lt;Constant&gt;(rational(1, 2)) * commutator(commutator(H, t2), t2);
<span class="sb">```</span>

<span class="sb">due to the explicit use of specific dummy indices in the definition of `t2`. Using it more than once in a given product will produce an expresson where each dummy index appears more than 2 times, breaking the Einstein summation convention.</span>

<span class="sb">The issue is actually not the reuse of the same of operator object, but the reuse of dummy indices. A straightforward, but brittle, solution is to ensure that each dummy index is only used once. E.g.,</span>
<span class="sb">to use $\hat{t}_2$ more than once in an expression we must make several versions of it, each with a separate set of dummy indices:</span>

<span class="sb">```c++</span>
<span class="sb">auto t2_0 =</span>
<span class="sb">      ex&lt;Constant&gt;(rational(1, 4)) *</span>
<span class="sb">      ex&lt;Tensor&gt;(L&quot;t&quot;, std::array{L&quot;a_1&quot;, L&quot;a_2&quot;}, std::array{L&quot;i_1&quot;, L&quot;i_2&quot;},</span>
<span class="sb">                 Symmetry::antisymm) *</span>
<span class="sb">      ex&lt;FNOperator&gt;(std::array{L&quot;a_1&quot;, L&quot;a_2&quot;}, std::array{L&quot;i_1&quot;, L&quot;i_2&quot;});</span>

<span class="sb">auto t2_1 =</span>
<span class="sb">      ex&lt;Constant&gt;(rational(1, 4)) *</span>
<span class="sb">      ex&lt;Tensor&gt;(L&quot;t&quot;, std::array{L&quot;a_3&quot;, L&quot;a_4&quot;}, std::array{L&quot;i_3&quot;, L&quot;i_4&quot;},</span>
<span class="sb">                 Symmetry::antisymm) *</span>
<span class="sb">      ex&lt;FNOperator&gt;(std::array{L&quot;a_3&quot;, L&quot;a_4&quot;}, std::array{L&quot;i_3&quot;, L&quot;i_4&quot;});</span>

<span class="sb">auto c_htt = ex&lt;Constant&gt;(rational(1, 4)) * commutator(commutator(H, t2_0), t2_1);</span>
<span class="sb">```</span>

This is too error-prone for making complex expressions. A better way is to represent $\hat{t}_2$ by an object that generates tensor form with unique dummy indices generated on the fly. in SeQuant such MBPT <span class="ge">_operators_</span> live in <span class="sb">`mbpt`</span> namespace. The entire CCD amplitude equation is evaluated as follows:

```c++
<span class="gh">#include &lt;SeQuant/core/context.hpp&gt;</span>
<span class="gh">#include &lt;SeQuant/core/expr.hpp&gt;</span>
<span class="gh">#include &lt;SeQuant/core/tensor.hpp&gt;</span>
<span class="gh">#include &lt;SeQuant/core/op.hpp&gt;</span>
<span class="gh">#include &lt;SeQuant/domain/mbpt/convention.hpp&gt;</span>
<span class="gh">#include &lt;SeQuant/domain/mbpt/op.hpp&gt;</span>

inline auto commutator(auto op1, auto op2) {
  return op1 * op2 - op2 * op1;
}

int main() {
  using namespace sequant;
  using namespace sequant::mbpt;
  set_default_context(Context(make_min_sr_spaces(), Vacuum::SingleProduct));

  auto hbar = H(2) + commutator(H(2), T<span class="ge">_(2)) + ex&lt;Constant&gt;(rational(1,2)) * commutator(commutator(H(2), T_</span>(2)), T_(2));
  auto ccd_eq = vac_av(P(2) * hbar);
  std::wcout &lt;&lt; &quot;&lt;&quot; &lt;&lt; to_latex(P(2) * hbar) &lt;&lt; &quot;&gt; = &quot; &lt;&lt; to_latex(ccd_eq) &lt;&lt; std::endl;

  return 0;
}
<span class="sb">```</span>

<span class="sb">The result is</span>

<span class="sb">$$</span>
<span class="sb">\bigl({{{\frac{1}{4}}}{A^{{a_1}{a_2}}_ {{i_1}{i_2}}}{\bar{g}^{{i_1}{i_2}}_ {{a_1}{a_2}}}} - {{{\frac{1}{2}}}{A^{{a_1}{a_2}}_ {{i_1}{i_2}}}{f^{{a_3}}_ {{a_1}}}{\bar{t}^{{i_1}{i_2}}_ {{a_2}{a_3}}}} - {{A^{{a_1}{a_2}}_ {{i_1}{i_2}}}{\bar{g}^{{i_1}{a_3}}_ {{i_3}{a_1}}}{\bar{t}^{{i_2}{i_3}}_ {{a_2}{a_3}}}} + {{{\frac{1}{8}}}{A^{{a_1}{a_2}}_ {{i_1}{i_2}}}{\bar{g}^{{a_3}{a_4}}_ {{a_1}{a_2}}}{\bar{t}^{{i_1}{i_2}}_ {{a_3}{a_4}}}}</span>
<span class="sb">$$</span>

<span class="sb">$$</span>
<span class="sb">\qquad \quad + ~ {{{\frac{1}{8}}}{A^{{a_1}{a_2}}_ {{i_1}{i_2}}}{\bar{g}^{{i_1}{i_2}}_ {{i_3}{i_4}}}{\bar{t}^{{i_3}{i_4}}_ {{a_1}{a_2}}}} + {{{\frac{1}{2}}}{A^{{a_1}{a_2}}_ {{i_1}{i_2}}}{f^{{i_1}}_ {{i_3}}}{\bar{t}^{{i_2}{i_3}}_ {{a_1}{a_2}}}} + {{{\frac{1}{16}}}{A^{{a_1}{a_2}}_ {{i_1}{i_2}}}{\bar{g}^{{a_3}{a_4}}_ {{i_3}{i_4}}}{\bar{t}^{{i_1}{i_2}}_ {{a_3}{a_4}}}{\bar{t}^{{i_3}{i_4}}_ {{a_1}{a_2}}}}</span>
<span class="sb">$$</span>

<span class="sb">$$</span>
<span class="sb">\quad - ~ {{{\frac{1}{4}}}{A^{{a_1}{a_2}}_ {{i_1}{i_2}}}{\bar{g}^{{a_3}{a_4}}_ {{i_3}{i_4}}}{\bar{t}^{{i_1}{i_3}}_ {{a_3}{a_4}}}{\bar{t}^{{i_2}{i_4}}_ {{a_1}{a_2}}}} - {{{\frac{1}{4}}}{A^{{a_1}{a_2}}_ {{i_1}{i_2}}}{\bar{g}^{{a_3}{a_4}}_ {{i_3}{i_4}}}{\bar{t}^{{i_1}{i_2}}_ {{a_1}{a_3}}}{\bar{t}^{{i_3}{i_4}}_ {{a_2}{a_4}}}}</span>
<span class="sb">$$</span>

<span class="sb">$$</span>
<span class="sb"> ~ + {{{\frac{1}{2}}}{A^{{a_1}{a_2}}_ {{i_1}{i_2}}}{\bar{g}^{{a_3}{a_4}}_ {{i_3}{i_4}}}{\bar{t}^{{i_1}{i_3}}_ {{a_1}{a_3}}}{\bar{t}^{{i_2}{i_4}}_ {{a_2}{a_4}}}}\bigr)</span>
<span class="sb">$$</span>

<span class="sb">The use of MBPT operators rather than their tensor-level forms not only solves problems with the reuse of dummy indices, but also allows to implement additional optimizations such as algebraic simplifications of complex operator expressions and avoiding evaluation of operator products whose vacuum expectation values are guaranteed to vanish. This allows very efficient derivation of complex equations, e.g. CC equations through CCSDTQ are derived in a fraction of a second on a  laptop:</span>

<span class="sb">```sh</span>
<span class="sb">$ cmake --build build --target srcc</span>
<span class="sb">$ time build/srcc  time ./srcc 4 t std so</span>
<span class="sb">CC equations [type=t,rank=1,spinfree=false,screen=true,use_topology=true,use_connectivity=true,canonical_only=true] computed in 0.0027805 seconds</span>
<span class="sb">R1(expS1) has 8 terms:</span>
<span class="sb">CC equations [type=t,rank=2,spinfree=false,screen=true,use_topology=true,use_connectivity=true,canonical_only=true] computed in 0.012890749999999999 seconds</span>
<span class="sb">R1(expS2) has 14 terms:</span>
<span class="sb">R2(expS2) has 31 terms:</span>
<span class="sb">CC equations [type=t,rank=3,spinfree=false,screen=true,use_topology=true,use_connectivity=true,canonical_only=true] computed in 0.039590500000000001 seconds</span>
<span class="sb">R1(expS3) has 15 terms:</span>
<span class="sb">R2(expS3) has 37 terms:</span>
<span class="sb">R3(expS3) has 47 terms:</span>
<span class="sb">CC equations [type=t,rank=4,spinfree=false,screen=true,use_topology=true,use_connectivity=true,canonical_only=true] computed in 0.107501417 seconds</span>
<span class="sb">R1(expS4) has 15 terms:</span>
<span class="sb">R2(expS4) has 38 terms:</span>
<span class="sb">R3(expS4) has 53 terms:</span>
<span class="sb">R4(expS4) has 74 terms:</span>
<span class="sb">./srcc 4 t std so  0.27s user 0.41s system 100% cpu 0.674 total</span>
<span class="sb">```</span>

<span class="gh"># Developers</span>

SeQuant is developed by the [<span class="nt">Valeev Research Group</span>](<span class="na">https://valeevgroup.github.io</span>) in the Department of Chemistry at Virginia Tech.

<span class="gh"># Acknowledgement</span>

Development of SeQuant has been possible thanks to the support of the US National Science Foundation (award 2217081) and the US Department of Energy (awards DE-SC0022327 and DE-SC0022263)
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Valeev Research Group.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>