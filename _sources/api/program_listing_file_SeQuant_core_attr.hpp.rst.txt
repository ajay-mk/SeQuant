
.. _program_listing_file_SeQuant_core_attr.hpp:

Program Listing for File attr.hpp
=================================

|exhale_lsh| :ref:`Return to documentation for file <file_SeQuant_core_attr.hpp>` (``SeQuant/core/attr.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   //
   // Created by Eduard Valeyev on 2019-02-13.
   //
   
   #ifndef SEQUANT_ATTR_HPP
   #define SEQUANT_ATTR_HPP
   
   #include <string>
   
   namespace sequant {
   
   enum class IndexSpaceMetric { Unit, General, Invalid };
   
   // clang-format off
   // clang-format on
   enum class ParticleSymmetry { symm, nonsymm, invalid };
   
   // clang-format off
   // clang-format on
   enum class Symmetry { symm, antisymm, nonsymm, invalid };
   
   enum class BraKetSymmetry { symm, conjugate, nonsymm, invalid };
   
   enum class SPBasis { spinorbital, spinfree };
   
   inline std::wstring to_wolfram(const Symmetry& symmetry) {
     std::wstring result;
     switch (symmetry) {
       case Symmetry::symm:
         result = L"indexSymm[1]";
         break;
       case Symmetry::antisymm:
         result = L"indexSymm[-1]";
         break;
       case Symmetry::nonsymm:
         result = L"indexSymm[0]";
         break;
       default:
         abort();
     }
     return result;
   }
   
   enum class BraKetPos { bra, ket, none };
   
   inline std::wstring to_wolfram(BraKetPos a) {
     using namespace std::literals;
     return L"indexType["s + (a == BraKetPos::bra ? L"bra" : L"ket") + L"]";
   }
   
   enum class Statistics {
     Null,
     FermiDirac,
     BoseEinstein,
     Arbitrary,
     Invalid = Null
   };
   
   enum class Action { create, annihilate, invalid };
   
   inline Action adjoint(Action action) {
     return action == Action::create ? Action::annihilate : Action::create;
   }
   
   inline std::wstring to_wolfram(Action a) {
     using namespace std::literals;
     return L"indexType["s + (a == Action::create ? L"cre" : L"ann") + L"]";
   }
   
   enum class Vacuum { Physical, SingleProduct, MultiProduct, Invalid };
   
   inline std::wstring to_string(Vacuum V) {
     switch (V) {
       case Vacuum::Physical:
         return L"PhysicalVacuum";
       case Vacuum::SingleProduct:
         return L"SingleProductVacuum";
       case Vacuum::MultiProduct:
         return L"MultiProductVacuum";
       case Vacuum::Invalid:
         return L"InvalidVacuum";
       default:
         abort();
     }
   }
   
   }  // namespace sequant
   
   #endif  // SEQUANT_ATTR_HPP
