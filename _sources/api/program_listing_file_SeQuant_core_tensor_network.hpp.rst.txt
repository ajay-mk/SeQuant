
.. _program_listing_file_SeQuant_core_tensor_network.hpp:

Program Listing for File tensor_network.hpp
===========================================

|exhale_lsh| :ref:`Return to documentation for file <file_SeQuant_core_tensor_network.hpp>` (``SeQuant/core/tensor_network.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   //
   // Created by Eduard Valeyev on 2019-02-02.
   //
   
   #ifndef SEQUANT_TENSOR_NETWORK_H
   #define SEQUANT_TENSOR_NETWORK_H
   
   #include <SeQuant/core/abstract_tensor.hpp>
   #include <SeQuant/core/container.hpp>
   #include <SeQuant/core/expr.hpp>
   #include <SeQuant/core/index.hpp>
   
   #include <cassert>
   #include <cstdlib>
   #include <memory>
   #include <stdexcept>
   #include <string>
   #include <string_view>
   #include <tuple>
   #include <utility>
   #include <vector>
   
   // forward declarations
   namespace bliss {
   class Graph;
   }
   
   namespace sequant {
   
   
   class TensorNetwork {
    public:
     constexpr static size_t max_rank = 256;
   
     // clang-format off
   
     // clang-format on
     class Edge {
      public:
       Edge() = default;
       explicit Edge(int terminal_idx, int position = 0)
           : first_(0), second_(terminal_idx), second_position_(position) {}
       Edge(int terminal_idx, const Index *idxptr, int position = 0)
           : first_(0),
             second_(terminal_idx),
             idxptr_(idxptr),
             second_position_(position) {}
       //    Edge(const Edge&) = default;
       //    Edge(Edge&&) = default;
       //    Edge& operator=(const Edge&) = default;
       //    Edge& operator=(Edge&&) = default;
   
       Edge &connect_to(int terminal_idx, int position = 0) {
         assert(first_ == 0 || second_ == 0);  // not connected yet
         assert(terminal_idx != 0);            // valid idx
         if (second_ == 0) {                   // unconnected Edge
           second_ = terminal_idx;
           second_position_ = position;
         } else if (std::abs(second_) <
                    std::abs(terminal_idx)) {  // connected to 2 Edges? ensure
                                               // first_ < second_
           assert(first_ == 0);                // there are slots left
           first_ = second_;
           first_position_ = second_position_;
           second_ = terminal_idx;
           second_position_ = position;
         } else {  // put into first slot
           first_ = terminal_idx;
           first_position_ = position;
         }
         return *this;
       }
   
       bool operator<(const Edge &other) const {
         if (std::abs(first_) == std::abs(other.first_)) {
           if (first_position_ == other.first_position_) {
             if (std::abs(second_) == std::abs(other.second_)) {
               return second_position_ < other.second_position_;
             } else {
               return std::abs(second_) < std::abs(other.second_);
             }
           } else {
             return first_position_ < other.first_position_;
           }
         } else {
           return std::abs(first_) < std::abs(other.first_);
         }
       }
   
       bool operator==(const Edge &other) const {
         return std::abs(first_) == std::abs(other.first_) &&
                std::abs(second_) == std::abs(other.second_) &&
                first_position_ == other.first_position_ &&
                second_position_ == other.second_position_;
       }
   
       auto first() const { return first_; }
       auto second() const { return second_; }
       auto first_position() const { return first_position_; }
       auto second_position() const { return second_position_; }
   
       auto size() const { return (first_ != 0) ? 2 : ((second_ != 0) ? 1 : 0); }
   
       const Index &idx() const {
         assert(idxptr_ != nullptr);
         return *idxptr_;
       }
   
      private:
       // if only connected to 1 terminal, this is always 0
       // otherwise first_ <= second_
       int first_ = 0;
       int second_ = 0;
       const Index *idxptr_ = nullptr;
       int first_position_ = 0;
       int second_position_ = 0;
     };
   
     enum class VertexType {
       Index,
       SPBundle,
       TensorBra,
       TensorKet,
       TensorBraKet,
       TensorCore
     };
   
    public:
     template <typename ExprPtrRange>
     TensorNetwork(ExprPtrRange &exprptr_range) {
       for (auto &&ex : exprptr_range) {
         auto t = std::dynamic_pointer_cast<AbstractTensor>(ex);
         if (t) {
           tensors_.emplace_back(t);
         } else {
           throw std::logic_error(
               "TensorNetwork::TensorNetwork: non-tensors in the given expression "
               "range");
         }
       }
     }
   
     const auto &tensors() const { return tensors_; }
   
     using named_indices_t = container::set<Index, Index::LabelCompare>;
   
     ExprPtr canonicalize(
         const container::vector<std::wstring> &cardinal_tensor_labels = {},
         bool fast = true, const named_indices_t *named_indices = nullptr);
   
     container::svector<std::pair<long, long>> factorize();
   
    private:
     // source tensors and indices
     container::svector<AbstractTensorPtr> tensors_;
   
     struct FullLabelCompare {
       using is_transparent = void;
       bool operator()(const Edge &first, const Edge &second) const {
         return first.idx().full_label() < second.idx().full_label();
       }
       bool operator()(const Edge &first, const std::wstring_view &second) const {
         return first.idx().full_label() < second;
       }
       bool operator()(const std::wstring_view &first, const Edge &second) const {
         return first < second.idx().full_label();
       }
     };
     // Index -> Edge, sorted by full label
     mutable container::set<Edge, FullLabelCompare> edges_;
     // set to true by init_edges();
     mutable bool have_edges_ = false;
     // ext indices do not connect tensors
     // sorted by *label* (not full label) of the corresponding value (Index)
     // this ensures that proto indices are not considered and all internal indices
     // have unique labels (not full labels)
     mutable named_indices_t ext_indices_;
   
     // replacements of anonymous indices produced by the last call to
     // canonicalize()
     container::map<Index, Index> idxrepl_;
   
     void init_edges() const;
   
    public:
     const auto &edges() const {
       init_edges();
       return edges_;
     }
   
   
     const auto &ext_indices() const {
       if (edges_.empty()) init_edges();
       return ext_indices_;
     }
   
     const auto &idxrepl() const { return idxrepl_; };
   
    public:
   
     std::tuple<std::shared_ptr<bliss::Graph>, std::vector<std::wstring>,
                std::vector<std::size_t>, std::vector<VertexType>>
     make_bliss_graph(const named_indices_t *named_indices = nullptr) const;
   };
   
   }  // namespace sequant
   
   #endif  // SEQUANT_TENSOR_NETWORK_H
